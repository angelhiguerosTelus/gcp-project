// Generated by CoffeeScript 2.6.0
(function() {
  var ConnectionFactory, PostgreSQLClient, PostgreSQLClient2, PostgreSQLClientPool, PostgreSQLClientPool2, PostgreSQLConnectionFactory, PostgreSQLConnectionFactory2, SQLClient, SQLClientPool, Url, error, pg, querystring,
    boundMethodCheck = function(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new Error('Bound instance method accessed before binding'); } };

  SQLClient = require('./sql-client').SQLClient;

  SQLClientPool = require('./sql-client-pool').SQLClientPool;

  ConnectionFactory = require('./connection-factory').ConnectionFactory;

  pg = require('pg');

  Url = require('url');

  querystring = require('querystring');

  try {
    if (pg.__lookupGetter__("native") == null) {
      pg = pg.native;
    }
  } catch (error1) {
    error = error1;
    console.log(error);
  }

  // PostgreSQLConnectionFactory does not use any of node-pg's built-in pooling.
  PostgreSQLConnectionFactory = class PostgreSQLConnectionFactory extends ConnectionFactory {
    constructor() {
      super();
      this.open_connection = this.open_connection.bind(this);
      this.pre_process_sql = this.pre_process_sql.bind(this);
    }

    open_connection(connect_string, callback) {
      var connection;
      boundMethodCheck(this, PostgreSQLConnectionFactory);
      connection = new pg.Client(connect_string);
      return connection.connect((err) => {
        return callback(err, connection);
      });
    }

    pre_process_sql(sql, bindvars, callback) {
      var index;
      boundMethodCheck(this, PostgreSQLConnectionFactory);
      if ((sql != null) && (bindvars != null)) {
        index = 1;
        sql = sql.replace(/\?/g, (function() {
          return '$' + index++;
        }));
      }
      return callback(null, sql, bindvars);
    }

  };

  PostgreSQLClient = class PostgreSQLClient extends SQLClient {
    constructor(...options) {
      super(...options, new PostgreSQLConnectionFactory());
    }

  };

  PostgreSQLClientPool = class PostgreSQLClientPool extends SQLClientPool {
    constructor(...options) {
      super(...options, new PostgreSQLConnectionFactory());
    }

  };

  exports.PostgreSQLConnectionFactory = PostgreSQLConnectionFactory;

  exports.PostgreSQLClient = PostgreSQLClient;

  exports.PostgreSQLClientPool = PostgreSQLClientPool;

  PostgreSQLConnectionFactory2 = (function() {
    // PostgreSQLConnectionFactory2 DOES usenode-pg's built-in pooling.
    class PostgreSQLConnectionFactory2 extends PostgreSQLConnectionFactory {
      constructor() {
        super();
        this._parse_connect_string = this._parse_connect_string.bind(this);
        this.open_connection = this.open_connection.bind(this);
        this.close_connection = this.close_connection.bind(this);
        this.pg_pools_by_connect_string = {};
      }

      _parse_connect_string(connect_string) {
        var config, matches, name, parsed_path, path, qs, value;
        boundMethodCheck(this, PostgreSQLConnectionFactory2);
        if (typeof connect_string === 'string' && this._connect_string_regexp.test(connect_string)) {
          matches = connect_string.match(this._connect_string_regexp);
          config = {};
          config.database = matches[1];
          config.user = matches[2];
          config.password = matches[3];
          config.host = matches[4];
          if (matches[6] != null) {
            config.port = parseInt(matches[6]);
          }
          path = matches[7];
          parsed_path = Url.parse(path);
          config.database = parsed_path.pathname.substring(1);
          if (parsed_path.query != null) {
            qs = querystring.parse(parsed_path.query);
            for (name in qs) {
              value = qs[name];
              if (value === 'true') {
                value = true;
              } else if (value === 'false') {
                value = false;
              } else if (`${value}` === `${parseInt(value)}`) {
                value = parseInt(value);
              }
              config[name] = value;
            }
          }
          return config;
        } else {
          return connect_string;
        }
      }

      open_connection(connect_string, callback) {
        var key, pg_pool;
        boundMethodCheck(this, PostgreSQLConnectionFactory2);
        key = connect_string;
        if (typeof key !== 'string') {
          key = JSON.stringify(key);
        }
        pg_pool = this.pg_pools_by_connect_string[key];
        if (pg_pool == null) {
          pg_pool = new pg.Pool(this._parse_connect_string(connect_string));
          this.pg_pools_by_connect_string[key] = pg_pool;
        }
        return pg_pool.connect((err, client, done_fn) => {
          var connection;
          connection = client;
          if (connection != null) {
            connection._sqlclient_done = done_fn;
            connection._pg_pool_key = key;
            connection._pg_pool = pg_pool;
          }
          return callback(err, connection);
        });
      }

      close_connection(connection, callback) {
        boundMethodCheck(this, PostgreSQLConnectionFactory2);
        if ((connection != null ? connection._sqlclient_done : void 0) != null) {
          connection._sqlclient_done();
          return typeof callback === "function" ? callback(null) : void 0;
        } else {
          return super.close_connection(connection, callback);
        }
      }

    };

    PostgreSQLConnectionFactory2.prototype._connect_string_regexp = /^([^:]+):\/\/([^:]+):([^@]+)@([^:\/]+)(:([0-9]+))?(.*)$/;

    return PostgreSQLConnectionFactory2;

  }).call(this);

  PostgreSQLClient2 = class PostgreSQLClient2 extends SQLClient {
    constructor(...options) {
      super(...options, new PostgreSQLConnectionFactory2());
      this.disconnect = this.disconnect.bind(this);
      this.disconnect_and_end = this.disconnect_and_end.bind(this);
    }

    disconnect(options, callback) {
      var pg_pool_to_end, ref;
      boundMethodCheck(this, PostgreSQLClient2);
      if (typeof options === "function" && (callback == null)) {
        [callback, options] = [options, callback];
      }
      if (options != null ? options.end_pg_pool : void 0) {
        pg_pool_to_end = (ref = this.connection) != null ? ref._pg_pool : void 0;
      }
      return super.disconnect(options, (err) => {
        if ((typeof (pg_pool_to_end != null ? pg_pool_to_end.end : void 0) === "function") && !(pg_pool_to_end.ending || pg_pool_to_end.ended)) {
          pg_pool_to_end.end();
        }
        return callback(err);
      });
    }

    disconnect_and_end(callback) {
      boundMethodCheck(this, PostgreSQLClient2);
      return this.disconnect({
        end_pg_pool: true
      }, callback);
    }

  };

  PostgreSQLClientPool2 = class PostgreSQLClientPool2 extends SQLClientPool {
    constructor(...options) {
      super(...options, new PostgreSQLConnectionFactory2());
      this.destroy = this.destroy.bind(this);
      this.close = this.close.bind(this);
    }

    destroy(client, callback) {
      boundMethodCheck(this, PostgreSQLClientPool2);
      if (client != null) {
        return client.disconnect(callback);
      } else {
        return typeof callback === "function" ? callback() : void 0;
      }
    }

    close(callback) {
      boundMethodCheck(this, PostgreSQLClientPool2);
      return super.close((...args) => {
        var key, pg_pool, pools_to_close, ref, ref1;
        pools_to_close = (ref = this.factory) != null ? ref.pg_pools_by_connect_string : void 0;
        ref1 = pools_to_close != null ? pools_to_close : {};
        for (key in ref1) {
          pg_pool = ref1[key];
          if (!((pg_pool == null) || (pg_pool.ending || pg_pool.ended))) {
            pg_pool.end();
          }
        }
        return typeof callback === "function" ? callback(...args) : void 0;
      });
    }

  };

  exports.PostgreSQLConnectionFactory2 = PostgreSQLConnectionFactory2;

  exports.PostgreSQLClient2 = PostgreSQLClient2;

  exports.PostgreSQLClientPool2 = PostgreSQLClientPool2;

}).call(this);
