// Generated by CoffeeScript 2.6.0
(function() {
  var SQLRunner, Util, fs;

  fs = require('fs');

  Util = require('./util').Util;

  SQLRunner = (function() {
    class SQLRunner {
      constructor(client, options) {
        this._init = this._init.bind(this);
        this.set_client = this.set_client.bind(this);
        this.close = this.close.bind(this);
        this.execute_file = this.execute_file.bind(this);
        this._get_options = this._get_options.bind(this);
        this._handle_argv = this._handle_argv.bind(this);
        this._stringify_results = this._stringify_results.bind(this);
        this.main = this.main.bind(this);
        if ((client != null) || (options != null)) {
          this._init(client, options);
        }
      }

      _init(client, options) {
        var f, i, len, ref;
        if ((client != null) && (options == null) && (client.execute == null)) {
          options = client;
          client = null;
        }
        if ((client == null) && ((options != null ? options.client : void 0) != null)) {
          client = options.client;
          options.client = null;
        }
        if (options != null) {
          ref = ['stop_on_error'];
          for (i = 0, len = ref.length; i < len; i++) {
            f = ref[i];
            if (options[f]) {
              this[f] = options[f];
            }
          }
        }
        if (client != null) {
          return this.set_client(client);
        }
      }

      set_client(client) {
        return this.client = client;
      }

      close(callback) {
        if (this.client != null) {
          return this.client.disconnect(callback);
        } else {
          return typeof callback === "function" ? callback() : void 0;
        }
      }

      execute(sql, callback) {
        var action, error, responses, when_done;
        responses = [];
        error = null;
        if (Array.isArray(sql)) {
          action = (stmt, index, list, next) => {
            return this.client.execute(stmt, (err, ...tail) => {
              responses.push([err].concat(tail));
              if (err != null) {
                error = err;
                if (stop_on_error) {
                  return callback(error, responses);
                } else {
                  return next();
                }
              } else {
                return next();
              }
            });
          };
          when_done = () => {
            return callback(error, responses);
          };
          return Util.for_each_async(sql, action, when_done);
        } else {
          return this.client.execute(sql, callback);
        }
      }

      execute_file(file, encoding, callback) {
        var options;
        if ((callback == null) && typeof encoding === 'function') {
          callback = encoding;
          encoding = null;
        }
        options = {};
        if (encoding != null) {
          options.encoding = encoding;
        }
        return fs.readFile(file, options, (err, data) => {
          if (!Util.handle_error(err, callback)) {
            return execute(data.toString(), callback);
          }
        });
      }

      _get_options(additional = {}) {
        return Util.merge(this._BASE_OPTIONS, additional);
      }

      _handle_argv(argv) {
        if (argv.quiet) {
          argv.v = argv.verbose = false;
        }
        return argv;
      }

      _stringify_results(...results) {
        return JSON.stringify(results, null, 2);
      }

      main(argv, logfn, errfn, callback) {
        var ARGF, argf, buffer, original_argv, ref, ref1, yargs;
        // set default arguments
        if ((errfn != null) && (callback == null)) {
          callback = errfn;
          errfn = null;
        }
        if ((logfn != null) && (callback == null)) {
          callback = lognf;
          logfn = null;
        }
        if (argv == null) {
          argv = process.argv;
        }
        if (logfn == null) {
          logfn = console.log;
        }
        if (errfn == null) {
          errfn = console.error;
        }
        if (callback == null) {
          callback = process.exit;
        }
        // swap out process.argv so that yargs reads the function argument
        original_argv = process.argv;
        process.argv = argv;
        try {
          // read command line parameters using node-yargs
          // perform the rest of the operation in a try block so we can be
          // sure to restore process.argv when we're finished.
          yargs = require('yargs');
          argv = yargs.options(this._get_options()).usage('Usage: $0 [OPTIONS]').argv;
          argv = this._handle_argv(argv);
          // handle help
          if (argv.help) {
            yargs.showHelp(errfn);
            return callback();
          } else {
            // make sure we've got a client to run with
            if (!this.client) {
              if (!argv.quiet) {
                errfn("SQLClient not configured.");
              }
              return callback(3);
            } else {
              // read input files or stdin using node-argf
              ARGF = require('argf');
              argf = new ARGF(argv._);
              // after all data has been read, execute the input sql
              argf.on('finished', () => {
                var sql;
                sql = buffer.join("\n");
                if (argv.verbose) {
                  logfn(`Read ${sql.length} character(s) in ${buffer.length} line(s).`);
                }
                if (sql.length === 0) {
                  if (!argv.quiet) {
                    errfn("No input found. Cannot continue. (Try --help for help.)");
                  }
                  callback(2);
                } else {
                  if (argv.verbose) {
                    logfn("Executing.");
                  }
                }
                return this.execute(sql, (err, ...result) => {
                  if (err != null) {
                    if (!argv.quiet) {
                      if (argv.verbose) {
                        errfn("ERROR");
                      }
                      errfn("Encountered error:", err);
                      errfn("while executing SQL:\n", sql);
                    }
                    return callback(1);
                  } else {
                    if (argv.verbose) {
                      logfn("SUCCESS");
                    }
                    if (!argv.quiet) {
                      logfn(this._stringify_results(...result));
                    }
                    return callback();
                  }
                });
              });
              // create one big buffer containing all input data
              if (argv.verbose) {
                if (((ref = argv._) != null ? ref.length : void 0) > 0) {
                  logfn(`Reading from ${(ref1 = argv._) != null ? ref1.length : void 0} input files.`);
                } else {
                  logfn("Reading from stdin.");
                }
              }
              buffer = [];
              return argf.forEach((line) => {
                return buffer.push(line);
              });
            }
          }
        } finally {
          process.argv = original_argv;
        }
      }

    };

    SQLRunner.prototype.stop_on_error = false;

    SQLRunner.prototype._BASE_OPTIONS = {
      h: {
        alias: 'help',
        boolean: true,
        describe: "Show help"
      },
      v: {
        alias: 'verbose',
        boolean: true,
        describe: "Be more chatty."
      },
      q: {
        alias: 'quiet',
        boolean: true,
        describe: "Be less chatty."
      },
      'stop-on-error': {
        alias: 'stop_on_error',
        boolean: true,
        describe: "Stop on error"
      }
    };

    return SQLRunner;

  }).call(this);

  exports.SQLRunner = SQLRunner;

}).call(this);
